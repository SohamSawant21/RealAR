<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bubble Sort Visualization in AR</title>
    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #fff;
            background-color: #1a1a1a;
            overflow: hidden; /* Hide scrollbars */
        }
        
        /* Style for the container that holds UI elements */
        #info-container {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            padding: 10px;
            box-sizing: border-box;
        }

        #info-container h1 {
            margin: 0;
            font-weight: 400;
            font-size: 1.8em;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }

        #info-container p {
            font-size: 1em;
            color: #ccc;
            text-shadow: 0 0 3px #000;
        }
        
        /* Styling for the control buttons */
        #controls {
            margin-top: 10px;
        }
        
        button {
            background-color: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 0 5px;
        }

        button:hover {
            background-color: #555;
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            background-color: #333;
            color: #888;
            cursor: not-allowed;
        }

        /* The AR button has its own default styling, but we can override it if needed */
        #ar-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 101;
        }
    </style>

    <!-- 
      FIX: An import map is added to tell the browser how to resolve "bare" module
      specifiers like "three". This is the modern, correct way to import libraries
      and fixes the "Failed to resolve module specifier" error.
    -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info-container">
        <h1>3D Bubble Sort</h1>
        <p>Watch the Bubble Sort algorithm animate in 3D. Use your mouse/finger to look around.</p>
        <div id="controls">
            <button id="sort-btn">Start Sort</button>
            <button id="reset-btn">Reset</button>
        </div>
    </div>
    
    <!-- This is where the 3D scene will be rendered -->

    <script type="module">
        // FIX: The imports are updated to use the bare module specifiers ("three")
        // defined in the import map above.
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- CONFIGURATION & SETUP ---
        // You can easily change these values to customize the visualization!
        const CUBE_COLOR = 0x007bff; // A nice blue color
        const HIGHLIGHT_COLOR = 0xffc107; // Yellow for comparison
        const SORTED_COLOR = 0x28a745; // Green for sorted elements
        const ANIMATION_SPEED_MS = 500; // Speed of animations in milliseconds
        
        let initialData = [5, 6, 1, 3]; // The array to be sorted. Change this to sort different data!
        
        let scene, camera, renderer, controls;
        let cubesGroup; // A group to hold all our cubes for easy management
        let isSorting = false;

        // --- INITIALIZATION ---
        init();

        function init() {
            // Create a scene, the container for all our 3D objects
            scene = new THREE.Scene();
            
            // Set up the camera, which defines our viewpoint
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10); // Position the camera
            camera.lookAt(0, 0, 0);

            // Set up the renderer, which draws the scene onto the screen
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            
            // Enable WebXR for Augmented Reality
            renderer.xr.enabled = true;

            // Add lighting to the scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Add OrbitControls to allow camera movement with mouse/touch
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Makes camera movement feel smoother
            controls.target.set(0, 2, 0); // Point controls at the center of our cubes

            // Create and add the cubes to the scene
            createCubes();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // Add UI Listeners
            document.getElementById('sort-btn').addEventListener('click', startSort);
            document.getElementById('reset-btn').addEventListener('click', reset);
            
            // Add the AR button to the page
            const arButton = ARButton.createButton(renderer);
            arButton.id = 'ar-button'; // Assign an ID for styling
            document.body.appendChild(arButton);
            
            // Start the animation loop
            renderer.setAnimationLoop(animate);
        }

        // --- OBJECT CREATION ---
        function createCubes() {
            if (cubesGroup) {
                scene.remove(cubesGroup); // Remove old group if it exists
                // Dispose of old geometry and materials to free up memory
                cubesGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            cubesGroup = new THREE.Group();
            const cubeWidth = 1;
            const spacing = 1.5;
            const totalWidth = (initialData.length - 1) * spacing;

            initialData.forEach((value, index) => {
                const geometry = new THREE.BoxGeometry(cubeWidth, value, cubeWidth);
                const material = new THREE.MeshStandardMaterial({ color: CUBE_COLOR });
                const cube = new THREE.Mesh(geometry, material);
                
                // Position the cube
                // We center the cubes by offsetting their position
                const xPos = index * spacing - totalWidth / 2;
                cube.position.set(xPos, value / 2, 0);
                
                // Store the original value for sorting logic
                cube.userData = { originalValue: value };

                cubesGroup.add(cube);
            });
            
            scene.add(cubesGroup);
        }
        
        // --- BUBBLE SORT ALGORITHM & ANIMATION ---
        async function bubbleSort() {
            isSorting = true;
            const cubes = cubesGroup.children.slice(); // Create a mutable copy of the cubes array
            let n = cubes.length;

            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    const cube1 = cubes[j];
                    const cube2 = cubes[j + 1];

                    // Highlight the cubes being compared
                    cube1.material.color.set(HIGHLIGHT_COLOR);
                    cube2.material.color.set(HIGHLIGHT_COLOR);
                    await sleep(ANIMATION_SPEED_MS); // Wait for user to see the highlight

                    if (cube1.userData.originalValue > cube2.userData.originalValue) {
                        // If a swap is needed, animate it
                        await swapCubes(cube1, cube2);
                        
                        // Swap them in our logical array for the next comparison
                        [cubes[j], cubes[j + 1]] = [cubes[j + 1], cubes[j]];
                    }

                    // Reset color of the first cube unless it's already marked as sorted
                    if(!cube1.userData.sorted) {
                        cube1.material.color.set(CUBE_COLOR);
                    }
                }
                 // The last element in this pass is now sorted, so color it green
                const sortedCube = cubes[n - 1 - i];
                sortedCube.material.color.set(SORTED_COLOR);
                sortedCube.userData.sorted = true;
            }
            // Color the very first element green, as it's sorted by the end
            cubes[0].material.color.set(SORTED_COLOR);
            cubes[0].userData.sorted = true;

            isSorting = false;
            document.getElementById('sort-btn').disabled = false;
        }

        // --- ANIMATION HELPERS ---
        
        // A helper function to smoothly swap the position of two cubes
        function swapCubes(cube1, cube2) {
            return new Promise(resolve => {
                const pos1_x = cube1.position.x;
                const pos2_x = cube2.position.x;
                const duration = ANIMATION_SPEED_MS / 2; // Make swap faster than the pause
                let startTime = null;

                function animateSwap(currentTime) {
                    if (!startTime) startTime = currentTime;
                    const elapsedTime = currentTime - startTime;
                    const progress = Math.min(elapsedTime / duration, 1); // progress goes from 0 to 1

                    // Interpolate positions
                    cube1.position.x = pos1_x + (pos2_x - pos1_x) * progress;
                    cube2.position.x = pos2_x + (pos1_x - pos2_x) * progress;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateSwap);
                    } else {
                        // Finalize positions to avoid floating point inaccuracies
                        cube1.position.x = pos2_x;
                        cube2.position.x = pos1_x;
                        resolve();
                    }
                }
                requestAnimationFrame(animateSwap);
            });
        }
        
        // A simple sleep/delay function that works with async/await
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- EVENT HANDLERS ---
        function startSort() {
            if (isSorting) return;
            // First, reset to initial state to ensure a clean sort
            reset();
            document.getElementById('sort-btn').disabled = true;
            document.getElementById('reset-btn').disabled = true;
            // A small delay to ensure the scene is reset before sorting
            setTimeout(() => {
                bubbleSort().then(() => {
                    document.getElementById('reset-btn').disabled = false;
                });
            }, 100);
        }

        function reset() {
            if (isSorting) return;
            createCubes(); // Re-create cubes in their initial state
            document.getElementById('sort-btn').disabled = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- RENDER LOOP ---
        function animate() {
            controls.update(); // Update camera controls
            renderer.render(scene, camera); // Render the scene
        }
    </script>
</body>
</html>