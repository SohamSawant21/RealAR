<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Bubble Sort with AR</title>
    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            color: #fff;
            background-color: #1a1a1a;
            overflow: hidden; /* Hide scrollbars */
        }
        
        /* Main container for UI elements */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), rgba(0,0,0,0));
            pointer-events: none; /* Allow clicks to pass through to the canvas */
        }

        #ui-container > * {
            pointer-events: auto; /* Re-enable pointer events for UI children */
        }
        
        .control-panel {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }

        .control-panel h1 {
            margin: 0 0 10px 0;
            font-weight: 400;
            font-size: 1.8em;
            color: #fff;
            text-shadow: 0 0 5px #000;
        }

        .input-group {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .input-group label {
            font-size: 1em;
        }

        .input-group input[type="text"] {
            background-color: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px;
            border-radius: 6px;
            width: 200px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        .input-group input[type="text"].invalid {
            border-color: #e74c3c;
        }

        .input-group input[type="range"] {
            width: 150px;
        }
        
        .button-group button {
            background-color: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }

        .button-group button:hover:not(:disabled) {
            background-color: #555;
        }

        .button-group button:active:not(:disabled) {
            transform: scale(0.95);
        }

        .button-group button:disabled {
            background-color: #2b2b2b;
            color: #777;
            cursor: not-allowed;
        }
        
        #stats-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 100;
            pointer-events: none;
        }

        #stats-panel p {
            margin: 4px 0;
        }

        #ar-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 101;
        }

        .label {
            position: absolute;
            color: white;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 5px;
            transform: translate(-50%, -50%); /* Center the label */
            font-size: 16px;
            text-shadow: 0 0 3px black;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
            transition: opacity 0.3s;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui-container">
        <div class="control-panel">
            <h1>Interactive 3D Bubble Sort</h1>
            <div class="input-group">
                <label for="array-input">Array:</label>
                <input type="text" id="array-input" value="8, 3, 2, 7">
                <label for="speed-slider">Speed:</label>
                <input type="range" id="speed-slider" min="50" max="1000" value="500" step="10">
            </div>
            <div class="button-group">
                <button id="sort-btn">Start Sort</button>
                <button id="next-step-btn">Next Step</button>
                <button id="reset-btn">Reset</button>
            </div>
        </div>
    </div>
    
    <div id="stats-panel">
        <p>Comparisons: <span id="comparisons-stat">0</span></p>
        <p>Swaps: <span id="swaps-stat">0</span></p>
        <p>Array: <span id="array-stat"></span></p>
    </div>

    <!-- Container for 2D labels that overlay the 3D scene -->
    <div id="label-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // --- CONFIGURATION ---
        const CUBE_COLOR = 0x007bff;
        const HIGHLIGHT_COLOR = 0xffc107;
        const SORTED_COLOR = 0x28a745;
        let animationSpeedMs = 500;

        // --- GLOBAL STATE ---
        let scene, camera, renderer, controls;
        let cubesGroup, labels = [];
        let isSorting = false, isAutoSorting = false, isAnimating = false;
        let sortGenerator = null;
        let stats = { comparisons: 0, swaps: 0 };
        
        // --- INITIALIZATION ---
        init();

        function init() {
            // Scene & Camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 12);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            renderer.xr.enabled = true;

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 2, 0);

            // UI & Event Listeners
            setupUI();

            // Initial scene setup
            reset();
            
            // Render loop
            renderer.setAnimationLoop(animate);
        }

        function setupUI() {
            document.getElementById('sort-btn').addEventListener('click', toggleAutoSort);
            document.getElementById('reset-btn').addEventListener('click', reset);
            document.getElementById('next-step-btn').addEventListener('click', nextStep);
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                // Invert slider value so left is slow, right is fast
                animationSpeedMs = 1050 - e.target.value;
            });
            document.getElementById('array-input').addEventListener('change', reset);
            
            const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            arButton.id = 'ar-button';
            document.body.appendChild(arButton);
            
            window.addEventListener('resize', onWindowResize, false);
        }
        
        // --- OBJECT & LABEL CREATION ---
        function createCubes(dataArray) {
            // Clean up old objects
            if (cubesGroup) {
                scene.remove(cubesGroup);
                cubesGroup.children.forEach(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            labels.forEach(label => label.element.remove());
            labels = [];

            cubesGroup = new THREE.Group();
            const cubeWidth = 1;
            const spacing = 1.5;
            const totalWidth = (dataArray.length - 1) * spacing;
            const labelContainer = document.getElementById('label-container');

            dataArray.forEach((value, index) => {
                const geometry = new THREE.BoxGeometry(cubeWidth, value, cubeWidth);
                const material = new THREE.MeshStandardMaterial({ color: CUBE_COLOR });
                const cube = new THREE.Mesh(geometry, material);
                
                const xPos = index * spacing - totalWidth / 2;
                cube.position.set(xPos, value / 2, 0);
                cube.userData = { value: value };
                cubesGroup.add(cube);

                // Create a corresponding label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = value;
                labelContainer.appendChild(labelDiv);
                labels.push({ cube: cube, element: labelDiv });
            });
            
            scene.add(cubesGroup);
            updateStatsPanel();
        }

        // --- SORTING LOGIC ---
        function* bubbleSortGenerator() {
            const cubes = cubesGroup.children.slice();
            let n = cubes.length;

            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    const cube1 = cubes[j];
                    const cube2 = cubes[j + 1];

                    // Step 1: Highlight for comparison
                    cube1.material.color.set(HIGHLIGHT_COLOR);
                    cube2.material.color.set(HIGHLIGHT_COLOR);
                    stats.comparisons++;
                    updateStatsPanel();
                    yield; // Pause after highlighting

                    if (cube1.userData.value > cube2.userData.value) {
                        // Step 2: Swap if needed
                        isAnimating = true;
                        stats.swaps++;
                        swapCubes(cube1, cube2).then(() => isAnimating = false);
                        
                        // Logical swap
                        [cubes[j], cubes[j + 1]] = [cubes[j + 1], cubes[j]];
                        yield; // Pause during swap animation
                    }
                    
                    // Step 3: Unhighlight
                    if (!cube1.userData.sorted) cube1.material.color.set(CUBE_COLOR);
                    if (!cube2.userData.sorted) cube2.material.color.set(CUBE_COLOR);
                }
                const sortedCube = cubes[n - 1 - i];
                sortedCube.material.color.set(SORTED_COLOR);
                sortedCube.userData.sorted = true;
            }
            if (n > 0) {
                cubes[0].material.color.set(SORTED_COLOR);
                cubes[0].userData.sorted = true;
            }
            updateUI(false); // Sort finished
        }

        // --- ANIMATION & HELPERS ---
        function swapCubes(cube1, cube2) {
            return new Promise(resolve => {
                const pos1_x = cube1.position.x;
                const pos2_x = cube2.position.x;
                const duration = animationSpeedMs / 2;
                let startTime = null;

                function animateSwap(currentTime) {
                    if (!startTime) startTime = currentTime;
                    const progress = Math.min((currentTime - startTime) / duration, 1);
                    cube1.position.x = pos1_x + (pos2_x - pos1_x) * progress;
                    cube2.position.x = pos2_x + (pos1_x - pos2_x) * progress;
                    if (progress < 1) requestAnimationFrame(animateSwap);
                    else {
                        cube1.position.x = pos2_x;
                        cube2.position.x = pos1_x;
                        updateStatsPanel();
                        resolve();
                    }
                }
                requestAnimationFrame(animateSwap);
            });
        }
        
        function updateLabels() {
            labels.forEach(label => {
                const { cube, element } = label;
                const vector = new THREE.Vector3();
                cube.getWorldPosition(vector);
                vector.y += cube.geometry.parameters.height / 2 + 0.5; // Position above cube
                vector.project(camera);

                const x = (vector.x * .5 + .5) * renderer.domElement.clientWidth;
                const y = (vector.y * -.5 + .5) * renderer.domElement.clientHeight;

                element.style.transform = `translate(-50%, -50%) translate(${x}px,${y}px)`;
                element.style.opacity = vector.z < 1 ? '1' : '0'; // Hide if behind camera
            });
        }
        
        function updateStatsPanel() {
            document.getElementById('comparisons-stat').textContent = stats.comparisons;
            document.getElementById('swaps-stat').textContent = stats.swaps;
            const currentArray = cubesGroup.children
                .slice() // create copy
                .sort((a, b) => a.position.x - b.position.x) // sort by visual position
                .map(c => c.userData.value)
                .join(', ');
            document.getElementById('array-stat').textContent = `[${currentArray}]`;
        }

        // --- EVENT HANDLERS ---
        function toggleAutoSort() {
            isAutoSorting = !isAutoSorting;
            document.getElementById('sort-btn').textContent = isAutoSorting ? 'Pause' : 'Start Sort';
            if (isAutoSorting && !isSorting) {
                isSorting = true;
                sortGenerator = bubbleSortGenerator();
                document.getElementById('next-step-btn').disabled = true;
            }
        }
        
        function nextStep() {
            if (!isSorting) {
                isSorting = true;
                sortGenerator = bubbleSortGenerator();
            }
            if (!isAnimating && sortGenerator) {
                const result = sortGenerator.next();
                if (result.done) {
                    sortGenerator = null;
                }
            }
        }
        
        function reset() {
            const inputElement = document.getElementById('array-input');
            const input = inputElement.value;
            const parsedData = input.split(',')
                .map(n => parseFloat(n.trim()))
                .filter(n => !isNaN(n) && n > 0);
            
            inputElement.classList.remove('invalid'); // Reset validation style

            if (parsedData.length === 0) {
                console.error("Invalid input: Please enter a comma-separated list of positive numbers.");
                inputElement.classList.add('invalid');
                return;
            }
            
            isSorting = false;
            isAutoSorting = false;
            isAnimating = false;
            sortGenerator = null;
            stats = { comparisons: 0, swaps: 0 };
            
            createCubes(parsedData);
            updateUI(true);
        }

        function updateUI(isReady) {
            document.getElementById('sort-btn').disabled = !isReady;
            document.getElementById('next-step-btn').disabled = !isReady;
            document.getElementById('array-input').disabled = !isReady && isSorting;
            if (isReady) {
                 document.getElementById('sort-btn').textContent = 'Start Sort';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- RENDER LOOP ---
        function animate() {
            controls.update();
            updateLabels();

            if (isAutoSorting && !isAnimating && sortGenerator) {
                setTimeout(() => {
                    if(isAutoSorting) { // Check again in case user paused
                        const result = sortGenerator.next();
                        if (result.done) {
                            sortGenerator = null;
                            isAutoSorting = false;
                        }
                    }
                }, animationSpeedMs);
                isAnimating = true; // Use isAnimating as a lock to respect timeout
                setTimeout(() => isAnimating = false, animationSpeedMs);
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

